/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>

#include <stdio.h>
#include <unistd.h>

#include "mynfs.h"

my_open_creat_results *
my_open_1_svc(my_open_params *argp, struct svc_req *rqstp)
{
	static my_open_creat_results  result;

	printf("open %s\n", argp->path);

	int ac;
	switch (argp->my_access_flag) {
		case _O_RDONLY: ac = O_RDONLY;
			break;
		case _O_WRONLY: ac = O_WRONLY;
			break;
		case _O_RDWR: ac = O_RDWR;
			break;
		default: result.status = -1;
			result.my_open_creat_results_u.my_errno = EACCES;
			return &result;
	}
	result.status = open(argp->path, ac);
	if (result.status == -1) {
		result.my_open_creat_results_u.my_errno = errno;
	} else {
		result.my_open_creat_results_u.success = result.status;
	}
	close(result.status);

	return &result;
}

my_open_creat_results *
my_creat_1_svc(my_creat_params *argp, struct svc_req *rqstp)
{
	static my_open_creat_results  result;

	printf("creat %s\n", argp->path);

	result.status = creat(argp->path, S_IRWXU);
	if (result.status == -1) {
		result.my_open_creat_results_u.my_errno = errno;
	} else {
		result.my_open_creat_results_u.success = result.status;
	}
	close(result.status);

	return &result;
}

my_read_results *
my_read_1_svc(my_read_params *argp, struct svc_req *rqstp)
{
	static my_read_results  result;

	printf("read %s count %d\n", argp->path, argp->count);

	int fd = open(argp->path, O_RDONLY);
	if (fd == -1) {
		result.status = -1;
		result.my_read_results_u.my_errno = errno;
		return &result;
	}

	int lseek_status = lseek(fd, argp->offset, SEEK_SET);
	if (lseek_status == -1) {
		result.status = -1;
		result.my_read_results_u.my_errno = errno;
		return &result;
	}

	result.my_read_results_u.buf = (char *)malloc(argp->count);
	result.status = read(fd, result.my_read_results_u.buf, argp->count);
	if (result.status == -1) {
		result.my_read_results_u.my_errno = errno;
	} else {
		result.my_read_results_u.buf[result.status] = '\0';
	}
	close(fd);

	return &result;
}

my_write_results *
my_write_1_svc(my_write_params *argp, struct svc_req *rqstp)
{
	static my_write_results  result;

	printf("write %s %s\n", argp->path, argp->buf);

	int fd = open(argp->path, O_WRONLY);
	if (fd == -1) {
		result.status = -1;
		result.my_write_results_u.my_errno = errno;
		return &result;
	}

	int lseek_status = lseek(fd, argp->offset, SEEK_SET);
	if (lseek_status == -1) {
		result.status = -1;
		result.my_write_results_u.my_errno = errno;
		return &result;
	}

	result.status = write(fd, argp->buf, argp->buf_size);
	if (result.status == -1) {
		result.my_write_results_u.my_errno = errno;
	} else {
		result.my_write_results_u.bytes_written = result.status;
	}
	close(fd);

	return &result;
}

my_lseek_results *
my_lseek_1_svc(my_lseek_params *argp, struct svc_req *rqstp)
{
	static my_lseek_results  result;

	int fd = open(argp->path, O_WRONLY);
	if (fd == -1) {
		result.status = -1;
		result.my_lseek_results_u.my_errno = errno;
		return &result;
	}

	int lseek_status = lseek(fd, argp->offset, SEEK_SET);
	if (lseek_status == -1) {
		result.status = -1;
		result.my_lseek_results_u.my_errno = errno;
		return &result;
	}

	printf("lseek %s\n", argp->path);
	int wh;
	switch (argp->my_whence_flag) {
		case _SEEK_SET: wh = SEEK_SET;
			break;
		case _SEEK_CUR: wh = SEEK_CUR;
			break;
		case _SEEK_END: wh = SEEK_END;
			break;
		default: wh = SEEK_SET;
			break;
	}

	result.status = lseek(fd, argp->offset_to_set, wh);
	if (result.status == -1) {
		result.my_lseek_results_u.my_errno = errno;
	} else {
		result.my_lseek_results_u.offset_location = result.status;
	}
	close(fd);

	return &result;
}

my_close_results *
my_close_1_svc(my_close_params *argp, struct svc_req *rqstp)
{
	static my_close_results  result;

	/*printf("close %d\n", argp->fd);
	result.status = close(argp->fd);
	if (result.status == -1) {
		result.my_close_results_u.my_errno = errno;
	} else {
		result.my_close_results_u.success = 0;
	}*/

	return &result;
}
